const axios = require('axios');

exports.scanForSQLInjection = async (url) => {


    return {
        vulnerable : false,
        details: 'No SQL injection vulnerabilities found',
        recommendation : 'Use parameterized quires and input validation.'
    };

};


exports.scanForXSS = async (url) => {
  const payload = "<script>alert('XSS');</script>";
  try {
      const response = await axios.get(`${url}?q=${encodeURIComponent(payload)}`);
      if (response.data && response.data.includes(payload)) {
          return {
              vulnerable: true,
              details: 'Reflected XSS vulnerability detected.',
              recommendation: 'Use proper output encoding and CSP.'
          };
      }
  } catch (error) {
      return {
          vulnerable: false,
          details: 'Error occurred while testing for XSS.',
          recommendation: 'Ensure proper error handling in your application.'
      };
  }
  return {
      vulnerable: false,
      details: 'No XSS vulnerabilities found',
      recommendation: 'Use proper output encoding and CSP.'
  };
};


exports.scanForBrokenAuth = async (url) => {
  try {
      const response = await axios.get(url);
      if (response.headers['set-cookie'] && response.headers['set-cookie'].some(cookie => /sessionid=.*;/i.test(cookie))) {
          return {
              vulnerable: true,
              details: 'Weak or missing authentication mechanism detected.',
              recommendation: 'Use secure session management and multi-factor authentication.'
          };
      }
  } catch (error) {
      return {
          vulnerable: false,
          details: 'Error occurred while testing for Broken Authentication.',
          recommendation: 'Ensure proper authentication mechanisms are in place.'
      };
  }
  return {
      vulnerable: false,
      details: 'No Broken Authentication issues found',
      recommendation: 'Use secure session management and multi-factor authentication.'
  };
};

exports.scanForSensitiveDataExposure = async (url) => {
  try {
      const response = await axios.get(url);
      if (response.headers['server'] || response.headers['x-powered-by']) {
          return {
              vulnerable: true,
              details: 'Sensitive server information exposed in headers.',
              recommendation: 'Disable sensitive headers and use secure configurations.'
          };
      }
  } catch (error) {
      return {
          vulnerable: false,
          details: 'Error occurred while testing for Sensitive Data Exposure.',
          recommendation: 'Ensure secure headers and encrypt sensitive data.'
      };
  }
  return {
      vulnerable: false,
      details: 'No sensitive data exposure issues found',
      recommendation: 'Implement data encryption and secure storage practices.'
  };
};

exports.scanForXXE = async (url) => {
  const xmlPayload = `<?xml version="1.0" encoding="ISO-8859-1"?>
  <!DOCTYPE foo [
    <!ELEMENT foo ANY >
    <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
  <foo>&xxe;</foo>`;

  try {
      const response = await axios.post(url, xmlPayload, {
          headers: { 'Content-Type': 'application/xml' }
      });

      if (response.data && response.data.includes("root:")) {
          return {
              vulnerable: true,
              details: 'XXE vulnerability detected. Application processes external entities.',
              recommendation: 'Disable XML external entity processing in parsers.'
          };
      }
  } catch (error) {
      return {
          vulnerable: false,
          details: 'Error occurred while testing for XXE.',
          recommendation: 'Ensure secure XML parser configurations.'
      };
  }
  return {
      vulnerable: false,
      details: 'No XXE vulnerabilities found',
      recommendation: 'Disable XML external entity processing in parsers.'
  };
};

  
exports.scanForInsecureDeserialization = async (url) => {
  const payload = `O:8:"Exploit":0:{}`; // Serialized PHP or Java object
  try {
      const response = await axios.post(url, payload, {
          headers: { 'Content-Type': 'application/octet-stream' }
      });

      if (response.data && /unexpected|exception|error/i.test(response.data)) {
          return {
              vulnerable: true,
              details: 'Insecure deserialization vulnerability detected.',
              recommendation: 'Validate serialized data and use integrity checks.'
          };
      }
  } catch (error) {
      return {
          vulnerable: false,
          details: 'Error occurred while testing for Insecure Deserialization.',
          recommendation: 'Ensure secure deserialization practices.'
      };
  }
  return {
      vulnerable: false,
      details: 'No insecure deserialization issues found',
      recommendation: 'Validate serialized data and use integrity checks.'
  };
};

  
exports.scanForSecurityMisconfig = async (url) => {
  try {
      const response = await axios.get(url);

      const missingHeaders = [];
      if (!response.headers['content-security-policy']) missingHeaders.push('Content-Security-Policy');
      if (!response.headers['strict-transport-security']) missingHeaders.push('Strict-Transport-Security');

      if (missingHeaders.length > 0) {
          return {
              vulnerable: true,
              details: `Missing security headers: ${missingHeaders.join(', ')}`,
              recommendation: 'Add security headers to harden application defenses.'
          };
      }
  } catch (error) {
      return {
          vulnerable: false,
          details: 'Error occurred while testing for Security Misconfigurations.',
          recommendation: 'Ensure application configuration follows best practices.'
      };
  }
  return {
      vulnerable: false,
      details: 'No security misconfigurations found',
      recommendation: 'Regularly audit and follow best practices for configurations.'
  };
};

  
exports.scanForAccessControlIssues = async (url) => {
  try {
      const response = await axios.get(`${url}/admin`);

      if (response.status === 200) {
          return {
              vulnerable: true,
              details: 'Access to restricted endpoint allowed without proper authorization.',
              recommendation: 'Implement role-based access control and enforce strict authorization.'
          };
      }
  } catch (error) {
      return {
          vulnerable: false,
          details: 'No unauthorized access allowed.',
          recommendation: 'Ensure role-based access control is properly implemented.'
      };
  }
  return {
      vulnerable: false,
      details: 'No access control issues found',
      recommendation: 'Implement role-based access control and test for privilege escalation.'
  };
};

exports.scanForCSRF = async (url) => {
  try {
      const response = await axios.post(url, {}, {
          headers: { 'Referer': 'http://malicious-site.com' }
      });

      if (response.status === 200) {
          return {
              vulnerable: true,
              details: 'CSRF vulnerability detected. Application accepts forged requests.',
              recommendation: 'Use CSRF tokens and validate origin headers.'
          };
      }
  } catch (error) {
      return {
          vulnerable: false,
          details: 'Error occurred while testing for CSRF.',
          recommendation: 'Ensure CSRF protection mechanisms are in place.'
      };
  }
  return {
      vulnerable: false,
      details: 'No CSRF vulnerabilities found',
      recommendation: 'Use CSRF tokens and validate origin headers.'
  };
};

  
exports.scanForVulnerableComponents = async (url) => {
  try {
      const response = await axios.get(`${url}/package.json`);
      if (response.data) {
          const vulnerabilities = []; // Use an NPM audit or similar tool to detect vulnerabilities
          if (vulnerabilities.length > 0) {
              return {
                  vulnerable: true,
                  details: `Vulnerable components detected: ${vulnerabilities.join(', ')}`,
                  recommendation: 'Keep all dependencies up-to-date and monitor for advisories.'
              };
          }
      }
  } catch (error) {
      return {
          vulnerable: false,
          details: 'No access to dependency files or vulnerabilities detected.',
          recommendation: 'Ensure all dependencies are up-to-date.'
      };
  }
  return {
      vulnerable: false,
      details: 'No known vulnerable components found',
      recommendation: 'Keep all dependencies up-to-date and monitor for advisories.'
  };
};
