/**
 * SANS Top 25 Vulnerability Scanners
 * Implements scanning functionalities based on the SANS Top 25 Most Dangerous Software Errors
 */
const httpClient = require('../helpers/httpClient');
const { formatResult } = require('../helpers/resultAnalyzer');
const payloadGenerator = require('../helpers/payloadGenerator');
const logger = require('../helpers/logger');
const config = require('../config');

/**
 * Scan for Path Traversal vulnerabilities (CWE-22)
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForPathTraversal(url) {
  logger.info(`Scanning for Path Traversal: ${url}`);
  
  try {
    const payloads = payloadGenerator.getPayloadsForType('path_traversal')
      .slice(0, config.MAX_PAYLOADS_PER_VULN);
    
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // Define file patterns to look for in responses
    const fileContentPatterns = [
      { pattern: /root:.*:\/root:/i, description: 'Linux passwd file' },
      { pattern: /\[boot loader\]/i, description: 'Windows system.ini' },
      { pattern: /\[fonts\]/i, description: 'Windows system configuration' },
      { pattern: /\[extension\]/i, description: 'Windows configuration' },
      { pattern: /\[drivers\]/i, description: 'Windows drivers' },
      { pattern: /DOCUMENT_ROOT/i, description: 'Web server configuration' },
      { pattern: /HTTP_USER_AGENT/i, description: 'Web server environment' }
    ];
    
    // Test each path traversal payload via GET parameters
    for (const payload of payloads) {
      try {
        // Test via different parameter names that might handle file operations
        const paramNames = ['file', 'path', 'page', 'document', 'img', 'src', 'include'];
        
        for (const param of paramNames) {
          const response = await httpClient.get(url, { [param]: payload });
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          // Store evidence
          evidence.responses.push({
            payload,
            parameter: param,
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // Check response for file content patterns
          const matchedPattern = fileContentPatterns.find(pattern => pattern.pattern.test(responseData));
          if (matchedPattern) {
            isVulnerable = true;
            logger.warn(`Path Traversal detected at ${url} with payload ${payload} in parameter ${param}`);
            evidence.vulnerableParam = param;
            evidence.detectedFileType = matchedPattern.description;
            break;
          }
          
          // Look for error messages that might indicate path traversal attempts
          const errorPatterns = [
            /no such file/i, 
            /cannot find/i, 
            /not found/i, 
            /failed to open/i,
            /permission denied/i
          ];
          
          if (errorPatterns.some(pattern => pattern.test(responseData))) {
            logger.debug(`Possible file-related error detected with ${param}=${payload}`);
            evidence.possibleFileError = true;
          }
        }
        
        if (isVulnerable) break;
      } catch (error) {
        logger.debug(`Error testing path traversal payload ${payload}: ${error.message}`);
      }
    }
    
    const details = isVulnerable 
      ? 'Path Traversal vulnerability detected. The application allows access to files outside the intended directory.'
      : 'No path traversal vulnerabilities found';
      
    const recommendation = 'Validate and sanitize all file paths. Use whitelisting approaches for file access, ' +
      'implement proper access controls, and consider isolating file storage operations to a specific directory. ' +
      'Never pass user-supplied file paths directly to file system operations.';
    
    return formatResult('path_traversal', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Path Traversal: ${error.message}`);
    return formatResult(
      'path_traversal',
      false,
      `Error occurred during path traversal testing: ${error.message}`,
      'Implement proper file path validation and access controls.'
    );
  }
}

/**
 * Scan for Integer Overflow vulnerabilities (CWE-190)
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForIntegerOverflow(url) {
  logger.info(`Scanning for Integer Overflow: ${url}`);
  
  try {
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // Test values near integer boundaries
    const integerBoundaries = [
      '2147483647',  // MAX_INT (32-bit)
      '2147483648',  // MAX_INT + 1
      '-2147483648', // MIN_INT (32-bit)
      '-2147483649', // MIN_INT - 1
      '4294967295',  // Unsigned MAX_INT (32-bit)
      '4294967296',  // Unsigned MAX_INT + 1
      '9223372036854775807',  // MAX_INT (64-bit)
      '9223372036854775808',  // MAX_INT + 1 (64-bit)
      '18446744073709551615', // Unsigned MAX_INT (64-bit)
      '18446744073709551616'  // Unsigned MAX_INT + 1 (64-bit)
    ];
    
    // Find parameters that might handle numeric values
    const paramNames = ['id', 'quantity', 'count', 'size', 'length', 'price', 'amount'];
    
    for (const param of paramNames) {
      for (const value of integerBoundaries) {
        try {
          const response = await httpClient.get(url, { [param]: value });
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          // Store evidence
          evidence.responses.push({
            parameter: param,
            value,
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // Look for overflow indicators in responses
          const overflowPatterns = [
            /overflow/i,
            /numeric value out of range/i,
            /value too large/i,
            /exceeds.*limit/i,
            /negative results/i,
            /arithmetic exception/i
          ];
          
          if (overflowPatterns.some(pattern => pattern.test(responseData))) {
            isVulnerable = true;
            logger.warn(`Potential Integer Overflow detected at ${url} with ${param}=${value}`);
            evidence.vulnerableParam = param;
            break;
          }
          
          // Also try POST requests
          const postResponse = await httpClient.post(url, { [param]: value });
          const postResponseData = postResponse.data && postResponse.data.toString ? postResponse.data.toString() : '';
          
          evidence.responses.push({
            method: 'POST',
            parameter: param,
            value,
            status: postResponse.status,
            responseExcerpt: postResponseData.substring(0, 200)
          });
          
          if (overflowPatterns.some(pattern => pattern.test(postResponseData))) {
            isVulnerable = true;
            logger.warn(`Potential Integer Overflow detected in POST request at ${url} with ${param}=${value}`);
            evidence.vulnerableParam = param;
            evidence.method = 'POST';
            break;
          }
        } catch (error) {
          logger.debug(`Error testing integer overflow with ${param}=${value}: ${error.message}`);
        }
      }
      
      if (isVulnerable) break;
    }
    
    const details = isVulnerable 
      ? 'Integer Overflow vulnerability detected. The application may not properly handle integer boundary values.'
      : 'No integer overflow vulnerabilities found';
      
    const recommendation = 'Validate all numeric inputs, use appropriate data types with sufficient range, ' +
      'check for overflow/underflow conditions before arithmetic operations, and consider using libraries ' +
      'that handle large integers safely.';
    
    return formatResult('integer_overflow', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Integer Overflow: ${error.message}`);
    return formatResult(
      'integer_overflow',
      false,
      `Error occurred during integer overflow testing: ${error.message}`,
      'Implement proper numeric input validation and boundary checking.'
    );
  }
}

/**
 * Scan for Insecure File Upload vulnerabilities (CWE-434)
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForFileUpload(url) {
  logger.info(`Scanning for File Upload vulnerabilities: ${url}`);
  
  try {
    const evidence = { findings: [] };
    let isVulnerable = false;
    
    // First, find potential upload endpoints
    const uploadEndpoints = [
      `${url}/upload`,
      `${url}/file/upload`,
      `${url}/api/upload`,
      `${url}/images/upload`,
      `${url}/attachments/upload`,
      `${url}`
    ];
    
    // Malicious file types to test
    const maliciousFileTypes = [
      { extension: 'php', content: '<?php echo "File upload test"; ?>', contentType: 'application/x-httpd-php' },
      { extension: 'php5', content: '<?php echo "File upload test"; ?>', contentType: 'text/plain' },
      { extension: 'phtml', content: '<?php echo "File upload test"; ?>', contentType: 'text/plain' },
      { extension: 'jsp', content: '<% out.println("File upload test"); %>', contentType: 'text/plain' },
      { extension: 'asp', content: '<% Response.Write("File upload test") %>', contentType: 'text/plain' },
      { extension: 'js', content: 'alert("File upload test");', contentType: 'application/javascript' },
      { extension: 'html', content: '<script>alert("File upload test");</script>', contentType: 'text/html' }
    ];
    
    let uploadEndpoint = null;
    
    // Check each endpoint for file upload form or functionality
    for (const endpoint of uploadEndpoints) {
      try {
        const response = await httpClient.get(endpoint);
        const responseData = response.data && response.data.toString ? response.data.toString() : '';
        
        // Check if page contains file upload elements
        if (responseData.includes('<input type="file"') || 
            responseData.includes('multipart/form-data') ||
            responseData.includes('upload') ||
            responseData.includes('dropzone')) {
          logger.info(`Potential file upload endpoint found at ${endpoint}`);
          evidence.findings.push({
            type: 'upload_endpoint',
            url: endpoint
          });
          uploadEndpoint = endpoint;
          break;
        }
      } catch (error) {
        logger.debug(`Error checking endpoint ${endpoint}: ${error.message}`);
      }
    }
    
    // If we found a potential upload endpoint, test it
    if (uploadEndpoint) {
      for (const fileType of maliciousFileTypes) {
        try {
          // Create a mock file with malicious content
          const formData = new FormData();
          const file = new Blob([fileType.content], { type: fileType.contentType });
          formData.append('file', file, `test.${fileType.extension}`);
          
          const response = await httpClient.post(uploadEndpoint, formData, {
            headers: {
              'Content-Type': 'multipart/form-data'
            }
          });
          
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          evidence.findings.push({
            type: 'upload_attempt',
            fileType: fileType.extension,
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // Check for successful upload indicators
          if (response.status === 200 || response.status === 201) {
            if (!responseData.includes('error') && 
                !responseData.includes('invalid') && 
                !responseData.includes('not allowed')) {
              isVulnerable = true;
              logger.warn(`Potentially successful upload of ${fileType.extension} file at ${uploadEndpoint}`);
              evidence.vulnerableFileType = fileType.extension;
              break;
            }
          }
        } catch (error) {
          logger.debug(`Error testing file upload with ${fileType.extension}: ${error.message}`);
        }
      }
      
      // Also test for file name manipulation (double extension)
      if (!isVulnerable) {
        try {
          const formData = new FormData();
          const file = new Blob(['Test content'], { type: 'text/plain' });
          formData.append('file', file, 'test.jpg.php');
          
          const response = await httpClient.post(uploadEndpoint, formData, {
            headers: {
              'Content-Type': 'multipart/form-data'
            }
          });
          
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          evidence.findings.push({
            type: 'double_extension',
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          if (response.status === 200 || response.status === 201) {
            if (!responseData.includes('error') && 
                !responseData.includes('invalid') && 
                !responseData.includes('not allowed')) {
              isVulnerable = true;
              logger.warn(`Potentially successful upload of double extension file at ${uploadEndpoint}`);
              evidence.vulnerableFileType = 'double extension';
            }
          }
        } catch (error) {
          logger.debug(`Error testing double extension file upload: ${error.message}`);
        }
      }
    }
    
    const details = isVulnerable 
      ? 'File Upload vulnerability detected. The application may allow upload of dangerous file types.'
      : 'No obvious file upload vulnerabilities found';
      
    const recommendation = 'Validate file types using content inspection rather than extension, ' +
      'store uploaded files outside the web root, rename files to prevent overwriting, ' +
      'set restrictive permissions, and scan uploads for malware.';
    
    return formatResult('file_upload', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for File Upload vulnerabilities: ${error.message}`);
    return formatResult(
      'file_upload',
      false,
      `Error occurred during file upload testing: ${error.message}`,
      'Implement proper file type validation and upload restrictions.'
    );
  }
}

/**
 * Scan for Hardcoded Credentials (CWE-798)
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForHardcodedCredentials(url) {
  logger.info(`Scanning for Hardcoded Credentials: ${url}`);
  
  try {
    const evidence = { findings: [] };
    let isVulnerable = false;
    
    // List of endpoints that might expose client-side scripts
    const endpoints = [
      `${url}`,
      `${url}/js/main.js`,
      `${url}/scripts/app.js`,
      `${url}/assets/js/main.js`,
      `${url}/dist/bundle.js`,
      `${url}/public/app.js`
    ];
    
    // Regex patterns to detect potential hardcoded credentials in client-side code
    const credentialPatterns = [
      { pattern: /apiKey\s*[:=]\s*['"][^'"]{5,}['"]/, type: 'API Key' },
      { pattern: /password\s*[:=]\s*['"][^'"]{4,}['"]/, type: 'Password' },
      { pattern: /secret\s*[:=]\s*['"][^'"]{4,}['"]/, type: 'Secret' },
      { pattern: /user\s*[:=]\s*['"][^'"]{3,}['"]/, type: 'Username' },
      { pattern: /key\s*[:=]\s*['"][^'"]{10,}['"]/, type: 'Key' },
      { pattern: /token\s*[:=]\s*['"][^'"]{10,}['"]/, type: 'Token' },
      { pattern: /authorization\s*[:=]\s*['"][^'"]{10,}['"]/, type: 'Authorization' },
      { pattern: /access_key\s*[:=]\s*['"][^'"]{5,}['"]/, type: 'Access Key' },
      { pattern: /dbpassword\s*[:=]\s*['"][^'"]{4,}['"]/, type: 'DB Password' },
      { pattern: /const\s+pw\s*=\s*['"][^'"]{4,}['"]/, type: 'Password Variable' }
    ];
    

    // Check each endpoint for potential credential exposure
    for (const endpoint of endpoints) {
      try {
        const response = await httpClient.get(endpoint);
        const responseData = response.data && response.data.toString ? response.data.toString() : '';
        
        for (const { pattern, type } of credentialPatterns) {
          const matches = responseData.match(pattern);
          
          if (matches && matches.length > 0) {
            isVulnerable = true;
            logger.warn(`Potential hardcoded ${type} found at ${endpoint}`);
            
            matches.forEach(match => {
              // Mask the actual credential in the evidence
              const sanitizedMatch = match.replace(/(['"])[^'"]{3}[^'"]*(['"])/, '$1***$2');
              
              evidence.findings.push({
                type: 'hardcoded_credential',
                credentialType: type,
                endpoint,
                match: sanitizedMatch
              });
            });
          }
        }
      } catch (error) {
        logger.debug(`Error checking endpoint ${endpoint}: ${error.message}`);
      }
    }
    
    // Check for environmental configuration files
    const configEndpoints = [
      `${url}/.env`,
      `${url}/config.js`,
      `${url}/config.json`,
      `${url}/settings.json`,
      `${url}/app.config.js`
    ];
    
    for (const endpoint of configEndpoints) {
      try {
        const response = await httpClient.get(endpoint);
        
        if (response.status === 200) {
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          // If we can access config files directly, that's an issue
          isVulnerable = true;
          logger.warn(`Configuration file exposed at ${endpoint}`);
          
          evidence.findings.push({
            type: 'exposed_config',
            endpoint,
            responseExcerpt: responseData.substring(0, 200).replace(/(['"])[^'"]{3}[^'"]*(['"])/g, '$1***$2') // Mask potential secrets
          });
        }
      } catch (error) {
        logger.debug(`Error checking config endpoint ${endpoint}: ${error.message}`);
      }
    }
    
    const details = isVulnerable 
      ? 'Hardcoded Credentials or exposed configuration detected. The application may have embedded credentials in client-side code.'
      : 'No obvious hardcoded credentials found in accessible client-side code';
      
    const recommendation = 'Store sensitive credentials in environment variables or a secure vault, ' +
      'never include secrets in client-side code, use proper authentication flows, ' +
      'restrict access to configuration files, and implement secret rotation policies.';
    
    return formatResult('hardcoded_credentials', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Hardcoded Credentials: ${error.message}`);
    return formatResult(
      'hardcoded_credentials',
      false,
      `Error occurred during hardcoded credentials testing: ${error.message}`,
      'Ensure credentials are stored securely and not embedded in code.'
    );
  }
}

/**
 * Scan for Output Neutralization vulnerabilities (CWE-116)
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForOutputNeutralization(url) {
  logger.info(`Scanning for Output Neutralization issues: ${url}`);
  
  try {
    // This scan looks for improper encoding/escaping in outputs
    // We'll test with various special characters and see if they're properly handled
    
    const specialCharPayloads = [
      '<script>console.log("test")</script>', // HTML/JS
      '"><script>console.log("test")</script><"', // HTML/JS with quotes
      '&lt;script&gt;alert(1)&lt;/script&gt;', // Already encoded - should stay encoded
      '<img src="x" onerror="alert(1)">', // XSS via img
      '`; DROP TABLE users; --', // SQL
      '{{7*7}}', // Template injection
      '${7*7}', // Template injection alternative syntax
      '<svg onload="alert(1)">', // SVG-based XSS
      '%3Cscript%3Ealert(1)%3C/script%3E', // URL encoded XSS
      '\\><script>alert(1)</script>', // Backslash evasion
    ];
    
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // Test reflection in search and other parameters
    const paramNames = ['q', 'search', 'query', 'id', 'name', 'input', 'text'];
    
    for (const param of paramNames) {
      for (const payload of specialCharPayloads) {
        try {
          const response = await httpClient.get(url, { [param]: payload });
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          // Add to evidence
          evidence.responses.push({
            parameter: param,
            payload,
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // Check if the payload is reflected without encoding
          if (responseData.includes(payload)) {
            // If payload contains HTML/JS and is reflected as-is, it's vulnerable
            if ((payload.includes('<script>') || 
                 payload.includes('onerror=') || 
                 payload.includes('onload=')) && 
                !isVulnerable) {
              isVulnerable = true;
              logger.warn(`Output not properly neutralized at ${url} with ${param}=${payload}`);
              evidence.vulnerableParam = param;
              evidence.vulnerablePayload = payload;
            }
          }
          
          // Check for template injection
          if ((payload.includes('{{') || payload.includes('${')) && 
              responseData.includes('49')) { // 7*7 = 49
            isVulnerable = true;
            logger.warn(`Potential template injection at ${url} with ${param}=${payload}`);
            evidence.vulnerableParam = param;
            evidence.vulnerablePayload = payload;
            evidence.templateInjection = true;
          }
        } catch (error) {
          logger.debug(`Error testing output neutralization with ${param}=${payload}: ${error.message}`);
        }
      }
    }
    
    // Also check for HTTP response splitting
    const headerInjectionPayloads = [
      'test%0D%0ASet-Cookie:%20malicious=1',
      'test%0D%0AContent-Type:%20text/html%0D%0A%0D%0A<script>alert(1)</script>'
    ];
    
    for (const param of paramNames) {
      for (const payload of headerInjectionPayloads) {
        try {
          const response = await httpClient.get(url, { [param]: payload });
          
          // Check response headers
          if (response.headers['set-cookie'] && 
              response.headers['set-cookie'].some(cookie => cookie.includes('malicious=1'))) {
            isVulnerable = true;
            logger.warn(`HTTP Response Splitting detected at ${url} with ${param}=${payload}`);
            evidence.httpResponseSplitting = true;
            evidence.vulnerableParam = param;
          }
        } catch (error) {
          logger.debug(`Error testing HTTP response splitting with ${param}=${payload}: ${error.message}`);
        }
      }
    }
    
    const details = isVulnerable 
      ? 'Output Neutralization vulnerability detected. The application does not properly encode or escape output.'
      : 'No obvious output neutralization issues found';
      
    const recommendation = 'Implement context-specific output encoding for HTML, JavaScript, CSS, and URLs. ' +
      'Use templating systems that auto-encode output, validate and sanitize all output, ' +
      'and implement Content Security Policy (CSP) headers.';
    
    return formatResult('output_neutralization', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Output Neutralization: ${error.message}`);
    return formatResult(
      'output_neutralization',
      false,
      `Error occurred during output neutralization testing: ${error.message}`,
      'Implement proper output encoding and escaping.'
    );
  }
}

/**
 * Scan for Missing Authentication (CWE-306)
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForMissingAuthentication(url) {
  logger.info(`Scanning for Missing Authentication: ${url}`);
  
  try {
    const evidence = { findings: [] };
    let isVulnerable = false;
    
    // List of sensitive endpoints that should require authentication
    const sensitiveEndpoints = [
      '/admin',
      '/dashboard',
      '/profile',
      '/settings',
      '/account',
      '/users',
      '/api/users',
      '/api/admin',
      '/api/data',
      '/api/settings',
      '/api/config',
      '/user/edit',
      '/user/delete'
    ];
    
    // Check each endpoint for access without authentication
    for (const endpoint of sensitiveEndpoints) {
      try {
        const endpointUrl = new URL(endpoint, url).toString();
        const response = await httpClient.get(endpointUrl);
        const responseData = response.data && response.data.toString ? response.data.toString() : '';
        
        evidence.findings.push({
          endpoint: endpointUrl,
          status: response.status,
          responseExcerpt: responseData.substring(0, 200)
        });
        
        // Check if the endpoint is accessible without auth
        // Signs of successful access include:
        // - 200 OK status
        // - No "login" or "unauthorized" in response
        // - Presence of sensitive-looking content
        if (response.status === 200) {
          if (!responseData.toLowerCase().includes('login') && 
              !responseData.toLowerCase().includes('sign in') && 
              !responseData.toLowerCase().includes('unauthorized') && 
              !responseData.toLowerCase().includes('authentication required')) {
                
            // Additional checks for sensitive content that suggests successful access
            const sensitiveContentPatterns = [
              /user list/i,
              /dashboard/i,
              /admin/i,
              /settings/i,
              /profile/i,
              /account/i,
              /\bname\b.*?\bemail\b/i,
              /\bid\b.*?\buser\b/i,
              /\["users"\]/i,
              /"role"\s*:\s*"admin"/i
            ];
            
            if (sensitiveContentPatterns.some(pattern => pattern.test(responseData))) {
              isVulnerable = true;
              logger.warn(`Sensitive endpoint accessible without authentication: ${endpointUrl}`);
              evidence.accessibleEndpoints = evidence.accessibleEndpoints || [];
              evidence.accessibleEndpoints.push(endpointUrl);
            }
          }
        }
      } catch (error) {
        logger.debug(`Error accessing endpoint ${endpoint}: ${error.message}`);
      }
    }
    
    // Also test API endpoints directly
    const apiEndpoints = [
      '/api/user',
      '/api/users',
      '/api/customer',
      '/api/customers',
      '/api/order',
      '/api/orders',
      '/api/product',
      '/api/data',
      '/api/admin'
    ];
    
    for (const endpoint of apiEndpoints) {
      try {
        const apiUrl = new URL(endpoint, url).toString();
        const response = await httpClient.get(apiUrl);
        
        // Check if API returns data without authentication
        if (response.status === 200) {
          const contentType = response.headers['content-type'] || '';
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          evidence.findings.push({
            endpoint: apiUrl,
            status: response.status,
            contentType,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // If API returns JSON data without authentication
          if (contentType.includes('application/json') && 
              responseData && 
              !responseData.includes('error') && 
              !responseData.includes('unauthorized') && 
              !responseData.includes('authentication')) {
                
            isVulnerable = true;
            logger.warn(`API endpoint accessible without authentication: ${apiUrl}`);
            evidence.accessibleApiEndpoints = evidence.accessibleApiEndpoints || [];
            evidence.accessibleApiEndpoints.push(apiUrl);
          }
        }
      } catch (error) {
        logger.debug(`Error accessing API endpoint ${endpoint}: ${error.message}`);
      }
    }
    
    const details = isVulnerable 
      ? 'Missing Authentication vulnerability detected. Sensitive endpoints or APIs are accessible without authentication.'
      : 'No obvious missing authentication issues found';
      
    const recommendation = 'Implement proper authentication for all sensitive endpoints and APIs. ' +
      'Use authentication frameworks, verify identity for all sensitive operations, ' +
      'implement principle of least privilege, and use centralized authentication mechanisms.';
    
    return formatResult('missing_authentication', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Missing Authentication: ${error.message}`);
    return formatResult(
      'missing_authentication',
      false,
      `Error occurred during missing authentication testing: ${error.message}`,
      'Ensure proper authentication for all sensitive functionality.'
    );
  }
}

/**
 * Scan for Buffer Overflow (CWE-120)
 * Note: Traditional buffer overflow is less common in web apps, this focuses on related input handling issues
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForBufferOverflow(url) {
    logger.info(`Scanning for Buffer-related vulnerabilities: ${url}`);
    
    try {
      const evidence = { responses: [] };
      let isVulnerable = false;
      
      // Generate large inputs to test buffer handling
      const largeInputs = [
        'A'.repeat(1000),
        'A'.repeat(5000),
        'A'.repeat(10000),
        'A'.repeat(50000),
        '%x'.repeat(1000)
      ];
      
      // Parameters to test
      const paramNames = ['id', 'name', 'input', 'data', 'text', 'comment', 'value'];
      
      // Error patterns that might indicate buffer issues
      const bufferErrorPatterns = [
        /stack/i,
        /overflow/i,
        /buffer/i,
        /memory/i,
        /crash/i,
        /exception/i,
        /segmentation/i,
        /allocation/i,
        /out of memory/i
      ];
      
      // Test each parameter with large inputs
      for (const param of paramNames) {
        for (const input of largeInputs) {
          try {
            const response = await httpClient.get(url, { [param]: input });
            const responseData = response.data && response.data.toString ? response.data.toString() : '';
            
            evidence.responses.push({
              parameter: param,
              inputLength: input.length,
              status: response.status,
              responseExcerpt: responseData.substring(0, 200)
            });
            
            // Look for error messages that might indicate buffer handling issues
            if (bufferErrorPatterns.some(pattern => pattern.test(responseData))) {
              isVulnerable = true;
              logger.warn(`Potential buffer handling issue detected at ${url} with ${param}=${input.substring(0, 20)}...`);
              evidence.vulnerableParam = param;
              evidence.inputLength = input.length;
              break;
            }
          } catch (error) {
            // If the request causes a server error, it might be a buffer issue
            if (error.response && error.response.status >= 500) {
              logger.debug(`Server error with large input in ${param}: ${error.message}`);
              evidence.responses.push({
                parameter: param,
                inputLength: input.length,
                status: error.response.status,
                error: error.message
              });
              
              // Check if error message suggests buffer issue
              if (bufferErrorPatterns.some(pattern => pattern.test(error.message))) {
                isVulnerable = true;
                logger.warn(`Potential buffer handling issue detected at ${url} with ${param}=${input.substring(0, 20)}...`);
                evidence.vulnerableParam = param;
                evidence.inputLength = input.length;
              }
            }
          }
          
          if (isVulnerable) break;
        }
        
        if (isVulnerable) break;
        
        // Also try POST requests
        for (const input of largeInputs) {
          try {
            const response = await httpClient.post(url, { [param]: input });
            const responseData = response.data && response.data.toString ? response.data.toString() : '';
            
            evidence.responses.push({
              method: 'POST',
              parameter: param,
              inputLength: input.length,
              status: response.status,
              responseExcerpt: responseData.substring(0, 200)
            });
            
            if (bufferErrorPatterns.some(pattern => pattern.test(responseData))) {
              isVulnerable = true;
              logger.warn(`Potential buffer handling issue detected in POST request at ${url} with ${param}=${input.substring(0, 20)}...`);
              evidence.vulnerableParam = param;
              evidence.inputLength = input.length;
              evidence.method = 'POST';
              break;
            }
          } catch (error) {
            if (error.response && error.response.status >= 500) {
              evidence.responses.push({
                method: 'POST',
                parameter: param,
                inputLength: input.length,
                status: error.response.status,
                error: error.message
              });
              
              if (bufferErrorPatterns.some(pattern => pattern.test(error.message))) {
                isVulnerable = true;
                logger.warn(`Potential buffer handling issue in POST request at ${url} with ${param}=${input.substring(0, 20)}...`);
                evidence.vulnerableParam = param;
                evidence.inputLength = input.length;
                evidence.method = 'POST';
              }
            }
          }
          
          if (isVulnerable) break;
        }
        
        if (isVulnerable) break;
      }
      
      const details = isVulnerable 
        ? 'Potential buffer handling vulnerability detected. The application may not properly handle very large inputs.'
        : 'No obvious buffer handling issues found';
        
      const recommendation = 'Validate input size before processing, use safe string handling functions, ' +
        'avoid fixed-size buffers when possible, implement proper input validation, ' +
        'and use languages/frameworks with built-in protection against buffer overflows.';
      
      return formatResult('buffer_overflow', isVulnerable, details, recommendation, evidence);
    } catch (error) {
      logger.error(`Error scanning for Buffer Overflow: ${error.message}`);
      return formatResult(
        'buffer_overflow',
        false,
        `Error occurred during buffer overflow testing: ${error.message}`,
        'Implement proper input size validation and use safe string handling functions.'
      );
    }
  }
  
  /**
   * Scan for Cross-Site Request Forgery (CSRF) vulnerabilities (CWE-352)
   * @param {String} url - Target URL
   * @returns {Promise<Object>} - Scan result
   */
  async function scanForCSRF(url) {
    logger.info(`Scanning for CSRF vulnerabilities: ${url}`);
    
    try {
      const evidence = { findings: [] };
      let isVulnerable = false;
      
      // First, check if the site uses forms
      const response = await httpClient.get(url);
      const responseData = response.data && response.data.toString ? response.data.toString() : '';
      
      // Check for forms in the HTML
      const formRegex = /<form[^>]*>[\s\S]*?<\/form>/gi;
      const forms = responseData.match(formRegex) || [];
      
      if (forms.length === 0) {
        logger.info(`No forms found at ${url}, checking additional pages`);
        
        // Check some common pages that might contain forms
        const additionalPages = [
          `${url}/login`,
          `${url}/register`,
          `${url}/contact`,
          `${url}/profile`,
          `${url}/account`,
          `${url}/settings`
        ];
        
        for (const page of additionalPages) {
          try {
            const pageResponse = await httpClient.get(page);
            const pageData = pageResponse.data && pageResponse.data.toString ? pageResponse.data.toString() : '';
            const pageForms = pageData.match(formRegex) || [];
            
            if (pageForms.length > 0) {
              logger.info(`Forms found at ${page}`);
              forms.push(...pageForms);
              break;
            }
          } catch (error) {
            logger.debug(`Error checking page ${page}: ${error.message}`);
          }
        }
      }
      
      if (forms.length > 0) {
        // Check if forms contain CSRF tokens
        let formsWithoutTokens = 0;
        
        for (const form of forms) {
          // Look for common CSRF token patterns
          const hasCSRFToken = /csrf|xsrf|token|nonce/i.test(form);
          
          if (!hasCSRFToken) {
            formsWithoutTokens++;
            evidence.findings.push({
              type: 'form_without_token',
              formExcerpt: form.substring(0, 200)
            });
          }
        }
        
        if (formsWithoutTokens > 0) {
          isVulnerable = true;
          logger.warn(`${formsWithoutTokens} forms without CSRF protection found at ${url}`);
          evidence.formsWithoutTokens = formsWithoutTokens;
          evidence.totalForms = forms.length;
        }
      }
      
      // Check for CSRF protection in cookies
      const cookies = response.headers['set-cookie'] || [];
      let hasSameSiteProtection = false;
      
      for (const cookie of cookies) {
        if (cookie.includes('SameSite=Strict') || cookie.includes('SameSite=Lax')) {
          hasSameSiteProtection = true;
          evidence.findings.push({
            type: 'samesite_cookie',
            cookie
          });
          break;
        }
      }
      
      if (!hasSameSiteProtection && cookies.length > 0) {
        isVulnerable = true;
        logger.warn(`No SameSite cookie protection found at ${url}`);
        evidence.cookiesWithoutSameSite = cookies.length;
      }
      
      // Check if CSRF headers are validated
      // Send an AJAX request with and without CSRF headers
      const testEndpoints = [
        `${url}/api/user`,
        `${url}/api/profile`,
        `${url}/api/settings`,
        url
      ];
      
      let csrfHeaderTested = false;
      
      for (const endpoint of testEndpoints) {
        try {
          // First request: no CSRF header
          const noHeaderResponse = await httpClient.post(endpoint, { test: 'value' });
          
          // Second request: with common CSRF header names but invalid values
          const withHeaderResponse = await httpClient.post(endpoint, { test: 'value' }, {
            headers: {
              'X-CSRF-Token': 'invalid-token',
              'X-Requested-With': 'XMLHttpRequest'
            }
          });
          
          // If both requests succeed with same status, might indicate lack of CSRF protection
          if (noHeaderResponse.status === withHeaderResponse.status && 
              noHeaderResponse.status < 400) {
            isVulnerable = true;
            logger.warn(`API endpoint ${endpoint} may lack CSRF header validation`);
            evidence.findings.push({
              type: 'csrf_header_validation',
              endpoint,
              noHeaderStatus: noHeaderResponse.status,
              withHeaderStatus: withHeaderResponse.status
            });
            csrfHeaderTested = true;
            break;
          }
        } catch (error) {
          // Ignore errors, endpoint might not exist
          logger.debug(`Error testing CSRF headers on ${endpoint}: ${error.message}`);
        }
      }
      
      const details = isVulnerable 
        ? 'CSRF vulnerability detected. The application may not properly protect against cross-site request forgery.'
        : 'No obvious CSRF vulnerabilities found';
        
      const recommendation = 'Implement anti-CSRF tokens in all forms, validate the token on the server, ' +
        'use SameSite cookie attribute, implement proper CORS headers, ' +
        'and verify the origin of requests.';
      
      return formatResult('csrf', isVulnerable, details, recommendation, evidence);
    } catch (error) {
      logger.error(`Error scanning for CSRF: ${error.message}`);
      return formatResult(
        'csrf',
        false,
        `Error occurred during CSRF testing: ${error.message}`,
        'Implement anti-CSRF tokens and SameSite cookie attributes.'
      );
    }
  }
  
  /**
   * Scan for Missing Encryption of Sensitive Data (CWE-311)
   * @param {String} url - Target URL
   * @returns {Promise<Object>} - Scan result
   */
  async function scanForMissingEncryption(url) {
    logger.info(`Scanning for Missing Encryption: ${url}`);
    
    try {
      const evidence = { findings: [] };
      let isVulnerable = false;
      
      // Check if site forces HTTPS
      const urlObj = new URL(url);
      const isHttps = urlObj.protocol === 'https:';
      
      if (!isHttps) {
        isVulnerable = true;
        logger.warn(`Site does not use HTTPS: ${url}`);
        evidence.findings.push({
          type: 'no_https',
          url
        });
      }
      
      // If site is HTTPS, check for HTTP -> HTTPS redirect
      if (isHttps) {
        try {
          // Try accessing via HTTP
          const httpUrl = url.replace('https://', 'http://');
          const response = await httpClient.get(httpUrl, { maxRedirects: 0 });
          
          // If we get here, site didn't redirect to HTTPS
          isVulnerable = true;
          logger.warn(`Site accessible via HTTP without redirect: ${httpUrl}`);
          evidence.findings.push({
            type: 'http_allowed',
            url: httpUrl,
            status: response.status
          });
        } catch (error) {
          // Check if error is due to redirect (which is good)
          if (error.response && error.response.status >= 300 && error.response.status < 400) {
            const location = error.response.headers['location'] || '';
            if (location.startsWith('https://')) {
              logger.info(`Site properly redirects HTTP to HTTPS`);
              evidence.findings.push({
                type: 'http_redirect',
                redirectLocation: location
              });
            } else {
              logger.debug(`HTTP request resulted in redirect to non-HTTPS URL: ${location}`);
              isVulnerable = true;
              evidence.findings.push({
                type: 'invalid_redirect',
                redirectLocation: location
              });
            }
          }
        }
      }
      
      // Check for proper security headers
      const securityHeaders = [
        'strict-transport-security',
        'content-security-policy',
        'x-content-type-options',
        'referrer-policy'
      ];
      
      try {
        const response = await httpClient.get(url);
        const headers = response.headers || {};
        
        const missingHeaders = securityHeaders.filter(header => !headers[header]);
        
        if (missingHeaders.length > 0) {
          isVulnerable = true;
          logger.warn(`Missing security headers: ${missingHeaders.join(', ')}`);
          evidence.findings.push({
            type: 'missing_security_headers',
            missingHeaders
          });
        }
        
        // Check HSTS header value if present
        if (headers['strict-transport-security']) {
          const hstsValue = headers['strict-transport-security'];
          if (!hstsValue.includes('max-age=') || parseInt(hstsValue.match(/max-age=(\d+)/)[1]) < 10886400) {
            isVulnerable = true;
            logger.warn(`HSTS header with insufficient max-age: ${hstsValue}`);
            evidence.findings.push({
              type: 'weak_hsts',
              value: hstsValue
            });
          }
        }
        
        // Check for cookies without secure flag
        const cookies = response.headers['set-cookie'] || [];
        const insecureCookies = cookies.filter(cookie => !cookie.includes('Secure'));
        
        if (insecureCookies.length > 0) {
          isVulnerable = true;
          logger.warn(`Cookies without Secure flag found: ${insecureCookies.length}`);
          evidence.findings.push({
            type: 'insecure_cookies',
            count: insecureCookies.length
          });
        }
      } catch (error) {
        logger.debug(`Error checking security headers: ${error.message}`);
      }
      
      // Check for login form submission over HTTP
      try {
        const loginPages = [
          `${url}/login`,
          `${url}/signin`,
          `${url}/user/login`,
          url
        ];
        
        for (const page of loginPages) {
          try {
            const response = await httpClient.get(page);
            const responseData = response.data && response.data.toString ? response.data.toString() : '';
            
            // Look for login forms
            const formRegex = /<form[^>]*action=["']([^"']*)["'][^>]*>[\s\S]*?<\/form>/gi;
            let match;
            
            while ((match = formRegex.exec(responseData)) !== null) {
              const formAction = match[1];
              
              if (formAction && formAction.startsWith('http:')) {
                isVulnerable = true;
                logger.warn(`Login form submits to HTTP URL: ${formAction}`);
                evidence.findings.push({
                  type: 'http_form_submission',
                  formAction
                });
                break;
              }
            }
          } catch (error) {
            logger.debug(`Error checking login page ${page}: ${error.message}`);
          }
        }
      } catch (error) {
        logger.debug(`Error checking login forms: ${error.message}`);
      }
      
      const details = isVulnerable 
        ? 'Missing Encryption vulnerability detected. The application may not properly encrypt sensitive data in transit.'
        : 'No obvious missing encryption issues found';
        
      const recommendation = 'Enforce HTTPS for all connections, implement proper HTTP Strict Transport Security (HSTS), ' +
        'use secure cookies, add relevant security headers, ' +
        'and ensure all form submissions use HTTPS.';
      
      return formatResult('missing_encryption', isVulnerable, details, recommendation, evidence);
    } catch (error) {
      logger.error(`Error scanning for Missing Encryption: ${error.message}`);
      return formatResult(
        'missing_encryption',
        false,
        `Error occurred during encryption testing: ${error.message}`,
        'Implement proper encryption for data in transit and at rest.'
      );
    }
  }
  
  // Export all scanner functions
  module.exports = {
    scanForPathTraversal,
    scanForIntegerOverflow,
    scanForFileUpload,
    scanForHardcodedCredentials,
    scanForOutputNeutralization,
    scanForMissingAuthentication,
    scanForBufferOverflow,
    scanForCSRF,
    scanForMissingEncryption
  };