/**
 * Advanced Vulnerability Scanners
 * Provides specialized and in-depth security checks for modern web applications
 */
const httpClient = require('../helpers/httpClient');
const { formatResult } = require('../helpers/resultAnalyzer');
const payloadGenerator = require('../helpers/payloadGenerator');
const logger = require('../helpers/logger');
const config = require('../config');

/**
 * Scan for Host Header Injection vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForHostHeaderInjection(url) {
  logger.info(`Scanning for Host Header Injection: ${url}`);
  
  try {
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // Prepare malicious host headers
    const hostHeaders = [
      'evil.com',
      'localhost',
      '127.0.0.1',
      'evil.com:80',
      'evil.com:443',
      `${new URL(url).hostname}:malicious.com`
    ];
    
    // Test each host header
    for (const hostHeader of hostHeaders) {
      try {
        const response = await httpClient.get(url, {}, {
          headers: {
            'Host': hostHeader,
            'X-Forwarded-Host': hostHeader
          }
        });
        
        const responseData = response.data && response.data.toString ? response.data.toString() : '';
        
        // Add to evidence
        evidence.responses.push({
          hostHeader,
          status: response.status,
          responseExcerpt: responseData.substring(0, 200)
        });
        
        // Check if host header was reflected in response
        if (responseData.includes(hostHeader) || 
            (response.headers['location'] && response.headers['location'].includes(hostHeader))) {
          isVulnerable = true;
          logger.warn(`Host Header Injection detected with header: ${hostHeader}`);
          evidence.vulnerableHeader = hostHeader;
          break;
        }
      } catch (error) {
        logger.debug(`Error testing host header ${hostHeader}: ${error.message}`);
      }
    }
    
    // Additional test with X-Forwarded-Host header
    if (!isVulnerable) {
      try {
        const xForwardedHost = 'malicious-forwarded-host.com';
        const response = await httpClient.get(url, {}, {
          headers: {
            'X-Forwarded-Host': xForwardedHost
          }
        });
        
        const responseData = response.data && response.data.toString ? response.data.toString() : '';
        
        // Add to evidence
        evidence.responses.push({
          header: 'X-Forwarded-Host',
          value: xForwardedHost,
          status: response.status,
          responseExcerpt: responseData.substring(0, 200)
        });
        
        // Check if X-Forwarded-Host was reflected
        if (responseData.includes(xForwardedHost) || 
            (response.headers['location'] && response.headers['location'].includes(xForwardedHost))) {
          isVulnerable = true;
          logger.warn(`Host Header Injection detected via X-Forwarded-Host header`);
          evidence.vulnerableHeader = 'X-Forwarded-Host';
        }
      } catch (error) {
        logger.debug(`Error testing X-Forwarded-Host header: ${error.message}`);
      }
    }
    
    const details = isVulnerable 
      ? 'Host Header Injection vulnerability detected. The application uses the Host header value unsafely, potentially enabling phishing attacks or cache poisoning.'
      : 'No Host Header Injection vulnerabilities found';
      
    const recommendation = 'Validate and sanitize Host headers before use. Never trust the Host header for security decisions. ' +
      'Implement strict host whitelisting, validate absolute URLs against known domains, and configure your web server ' +
      'to prevent Host header manipulation.';
    
    return formatResult('host_header_injection', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Host Header Injection: ${error.message}`);
    return formatResult(
      'host_header_injection',
      false,
      `Error occurred during Host Header Injection testing: ${error.message}`,
      'Ensure proper validation of HTTP headers, especially Host headers.'
    );
  }
}

/**
 * Scan for JSON Web Token (JWT) vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForJwtVulnerabilities(url) {
  logger.info(`Scanning for JWT vulnerabilities: ${url}`);
  
  try {
    const jwtPayloads = payloadGenerator.generateJwtPayloads();
    const evidence = { responses: [], jwtTokens: [] };
    let isVulnerable = false;
    
    // First, try to find endpoints that use JWT
    // Common endpoints that might use JWT
    const potentialJwtEndpoints = [
      `${url}/api/login`,
      `${url}/auth`,
      `${url}/token`,
      `${url}/api/auth`,
      `${url}/api/user`,
      `${url}`,
      `${url}/api`
    ];
    
    // Look for JWT in responses
    for (const endpoint of potentialJwtEndpoints) {
      try {
        const response = await httpClient.get(endpoint);
        const responseData = response.data && response.data.toString ? response.data.toString() : '';
        
        // Look for JWT pattern in response
        const jwtPattern = /eyJ[a-zA-Z0-9_-]+\.eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+/;
        const jwtMatches = responseData.match(jwtPattern);
        
        if (jwtMatches) {
          evidence.jwtTokens.push({
            endpoint,
            token: jwtMatches[0]
          });
          logger.info(`JWT token found in response from ${endpoint}`);
        }
        
        // Also check Authorization header in case of redirect
        if (response.headers['authorization'] && 
            response.headers['authorization'].startsWith('Bearer ey')) {
          evidence.jwtTokens.push({
            endpoint,
            token: response.headers['authorization'].replace('Bearer ', '')
          });
          logger.info(`JWT token found in Authorization header from ${endpoint}`);
        }
      } catch (error) {
        logger.debug(`Error accessing endpoint ${endpoint}: ${error.message}`);
      }
    }
    
    // Test JWT vulnerabilities using prepared payloads
    for (const jwtPayload of jwtPayloads) {
      for (const endpoint of potentialJwtEndpoints) {
        try {
          const response = await httpClient.get(endpoint, {}, {
            headers: {
              'Authorization': `Bearer ${jwtPayload}`
            }
          });
          
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          // Add to evidence
          evidence.responses.push({
            endpoint,
            jwtPayload,
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // Check for successful access or revealing errors
          // Status 200 with none algorithm or weak signature could indicate vulnerability
          if (response.status === 200 && 
              (jwtPayload.split('.').length === 3 && jwtPayload.split('.')[2] === '')) {
            isVulnerable = true;
            logger.warn(`Potential JWT vulnerability detected at ${endpoint} - accepted unsigned token`);
            evidence.vulnerableEndpoint = endpoint;
            break;
          }
          
          // Look for informative error messages
          if (responseData.includes('signature') && 
              (responseData.includes('invalid') || responseData.includes('failed'))) {
            // Not necessarily vulnerable but has JWT validation
            evidence.jwtValidationErrors = evidence.jwtValidationErrors || [];
            evidence.jwtValidationErrors.push({
              endpoint,
              errorMessage: responseData.substring(0, 200)
            });
          }
        } catch (error) {
          logger.debug(`Error testing JWT at ${endpoint}: ${error.message}`);
        }
      }
      
      if (isVulnerable) break;
    }
    
    const details = isVulnerable 
      ? 'JWT vulnerability detected. The application may accept unsigned or weakly signed JWT tokens.'
      : 'No obvious JWT vulnerabilities found';
      
    const recommendation = 'Use strong signing algorithms (RS256, ES256) instead of HS256. ' +
      'Validate all parts of the JWT including signature, expiration, algorithm and claims. ' +
      'Never accept "none" algorithm and implement proper key management.';
    
    return formatResult('jwt_vulnerabilities', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for JWT vulnerabilities: ${error.message}`);
    return formatResult(
      'jwt_vulnerabilities',
      false,
      `Error occurred during JWT vulnerability testing: ${error.message}`,
      'Ensure proper JWT implementation and validation.'
    );
  }
}

/**
 * Scan for Prototype Pollution vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForPrototypePollution(url) {
  logger.info(`Scanning for Prototype Pollution: ${url}`);
  
  try {
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // Prepare prototype pollution payloads
    // These try to pollute Object.prototype
    const payloads = [
      { "__proto__": { "polluted": "yes" } },
      { "constructor": { "prototype": { "polluted": "yes" } } },
      { "__proto__": { "toString": "polluted" } },
      { "__proto__.polluted": "yes" },
      { "a": { "__proto__": { "polluted": "yes" } } }
    ];
    
    // Potential endpoints that might process JSON
    const jsonEndpoints = [
      `${url}/api/data`,
      `${url}/api/user`,
      `${url}/api/settings`,
      `${url}/api`,
      url
    ];
    
    // Test payloads on endpoints
    for (const endpoint of jsonEndpoints) {
      for (const payload of payloads) {
        try {
          // Send payload as JSON to endpoint
          const response = await httpClient.post(endpoint, payload, {
            headers: { 'Content-Type': 'application/json' }
          });
          
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          // Add to evidence
          evidence.responses.push({
            endpoint,
            payload: JSON.stringify(payload),
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // Check for signs of successful pollution
          // This is challenging to detect automatically, but we can look for certain patterns
          if (responseData.includes('polluted') || 
              responseData.toLowerCase().includes('prototype') ||
              responseData.toLowerCase().includes('constructor')) {
            // Not definitive, but suspicious
            evidence.suspiciousResponses = evidence.suspiciousResponses || [];
            evidence.suspiciousResponses.push({
              endpoint,
              payload: JSON.stringify(payload),
              response: responseData.substring(0, 200)
            });
            logger.warn(`Potential prototype pollution indicator at ${endpoint}`);
          }
        } catch (error) {
          logger.debug(`Error testing prototype pollution at ${endpoint}: ${error.message}`);
        }
      }
    }
    
    // Detection via side effects - try to trigger behavior changes
    // This would normally require observable side effects
    try {
      // First request without pollution
      const normalResponse = await httpClient.get(url);
      
      // Then send a potential pollution payload
      await httpClient.post(url, { "__proto__": { "isAdmin": true } }, {
        headers: { 'Content-Type': 'application/json' }
      });
      
      // Then check if behavior changed
      const afterResponse = await httpClient.get(url);
      
      // Compare responses (simple check, not comprehensive)
      if (normalResponse.data !== afterResponse.data) {
        evidence.behaviorialChange = {
          before: normalResponse.data.substring(0, 100),
          after: afterResponse.data.substring(0, 100)
        };
        logger.warn('Potential behavior change detected after prototype pollution attempt');
        
        // This is just an indicator, not a definitive vulnerability
        isVulnerable = false; // Set to true only for confirmed vulnerabilities
      }
    } catch (error) {
      logger.debug(`Error in prototype pollution behavioral test: ${error.message}`);
    }
    
    const details = isVulnerable 
      ? 'Prototype Pollution vulnerability detected. The application may unsafely merge user-supplied JSON with JavaScript objects.'
      : 'No confirmed Prototype Pollution vulnerabilities found';
      
    const recommendation = 'Use Object.create(null) to create objects without prototype, ' +
      'avoid using recursive merge functions on user input, ' +
      'use Map instead of plain objects for user-controlled keys, ' +
      'and sanitize JSON input to prevent __proto__ and constructor properties.';
    
    return formatResult('prototype_pollution', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Prototype Pollution: ${error.message}`);
    return formatResult(
      'prototype_pollution',
      false,
      `Error occurred during Prototype Pollution testing: ${error.message}`,
      'Sanitize JSON input and use safe object manipulation techniques.'
    );
  }
}

/**
 * Scan for NoSQL Injection vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForNoSQLInjection(url) {
  logger.info(`Scanning for NoSQL Injection: ${url}`);
  
  try {
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // NoSQL injection payloads for various databases
    const payloads = [
      // MongoDB injection payloads
      { "username": { "$ne": null } },
      { "password": { "$ne": null } },
      { "username": { "$in": ["admin", "user", "root"] } },
      { "password": { "$gt": "" } }, // Greater than empty string
      { "$where": "sleep(500)" }, // Sleep injection
      { "username": "admin", "password": { "$regex": ".*" } }, // Regex bypass
      
      // URL parameter payloads
      "username[$ne]=null&password[$ne]=null",
      "username[$regex]=admin&password[$regex]=.*",
      "username[$exists]=true",
      
      // Document NoSQL operators
      { "$or": [ {"username": "admin"}, {"username": "administrator"} ] },
      { "$where": "this.username == 'admin'" }
    ];
    
    // Likely API endpoints
    const apiEndpoints = [
      `${url}/api/login`,
      `${url}/api/users`,
      `${url}/api/auth`,
      `${url}/api/data`,
      `${url}/login`,
      `${url}/auth`,
      url
    ];
    
    // Test JSON payloads
    for (const endpoint of apiEndpoints) {
      for (const payload of payloads) {
        try {
          // Skip URL payloads for POST tests
          if (typeof payload === 'string' && payload.includes('&')) continue;
          
          // Send as JSON payload
          const response = await httpClient.post(endpoint, payload, {
            headers: { 'Content-Type': 'application/json' }
          });
          
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          // Add to evidence
          evidence.responses.push({
            endpoint,
            payload: typeof payload === 'string' ? payload : JSON.stringify(payload),
            method: 'POST',
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // Look for signs of successful injection
          // Success indicators could be: 200 OK on auth endpoints, data leakage, etc.
          if (endpoint.includes('login') || endpoint.includes('auth')) {
            if (response.status === 200 && 
                (responseData.includes('success') || 
                 responseData.includes('token') || 
                 responseData.includes('user'))) {
              isVulnerable = true;
              logger.warn(`Potential NoSQL Injection at ${endpoint} with payload: ${JSON.stringify(payload)}`);
              evidence.vulnerableEndpoint = endpoint;
              evidence.successfulPayload = payload;
              break;
            }
          }
          
          // Check for MongoDB error messages
          if (responseData.includes('MongoError') || 
              responseData.includes('MongoDB') ||
              responseData.includes('CouchDB') ||
              responseData.includes('Mongoose')) {
            isVulnerable = true;
            logger.warn(`NoSQL database error detected at ${endpoint}`);
            evidence.vulnerableEndpoint = endpoint;
            evidence.errorMessage = responseData.substring(0, 200);
            break;
          }
        } catch (error) {
          logger.debug(`Error testing NoSQL injection at ${endpoint}: ${error.message}`);
          
          // Some errors might indicate vulnerability too
          if (error.response && error.response.data &&
              typeof error.response.data === 'string' &&
              (error.response.data.includes('MongoDB') || 
               error.response.data.includes('Mongoose'))) {
            isVulnerable = true;
            logger.warn(`NoSQL database error in exception at ${endpoint}`);
            evidence.vulnerableEndpoint = endpoint;
            evidence.errorMessage = error.response.data.substring(0, 200);
            break;
          }
        }
      }
      
      if (isVulnerable) break;
      
      // Test URL parameter payloads with GET
      for (const payload of payloads) {
        // Only use string payloads with URL parameters
        if (typeof payload !== 'string' || !payload.includes('&')) continue;
        
        try {
          const response = await httpClient.get(`${endpoint}?${payload}`);
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          // Add to evidence
          evidence.responses.push({
            endpoint,
            payload,
            method: 'GET',
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // Check for success indicators
          if (endpoint.includes('login') || endpoint.includes('auth')) {
            if (response.status === 200 && 
                (responseData.includes('success') || 
                 responseData.includes('token') || 
                 responseData.includes('user'))) {
              isVulnerable = true;
              logger.warn(`Potential NoSQL Injection at ${endpoint} with GET payload: ${payload}`);
              evidence.vulnerableEndpoint = endpoint;
              evidence.successfulPayload = payload;
              break;
            }
          }
        } catch (error) {
          logger.debug(`Error testing NoSQL GET injection at ${endpoint}: ${error.message}`);
        }
      }
      
      if (isVulnerable) break;
    }
    
    const details = isVulnerable 
      ? 'NoSQL Injection vulnerability detected. The application may not properly sanitize inputs used in NoSQL database queries.'
      : 'No NoSQL Injection vulnerabilities found';
      
    const recommendation = 'Use parameterized queries and input validation for NoSQL databases. ' +
      'Avoid constructing queries with user input and implement proper type checking. ' +
      'Use MongoDB\'s aggregation framework instead of $where operators when possible. ' +
      'Implement proper access controls and field-level encryption for sensitive data.';
    
    return formatResult('nosql_injection', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for NoSQL Injection: ${error.message}`);
    return formatResult(
      'nosql_injection',
      false,
      `Error occurred during NoSQL Injection testing: ${error.message}`,
      'Ensure proper input validation for NoSQL database queries.'
    );
  }
}

/**
 * Scan for Server-Side Template Injection (SSTI) vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForServerSideTemplateInjection(url) {
  logger.info(`Scanning for Server-Side Template Injection: ${url}`);
  
  try {
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // SSTI test payloads for different template engines
    const payloads = [
      // Generic/detection
      '${7*7}',
      '#{7*7}',
      '{{7*7}}',
      '<%= 7*7 %>',
      '{7*7}',
      '${{7*7}}',
      '#{7*7}',
      '*{7*7}',
      
      // Specific template engines
      '{{7*'+'7}}', // Twig/Jinja/Nunjucks - Adding concatenation to avoid detection
      '${T(java.lang.Runtime).getRuntime()}', // Java Expression Language
      '{{config}}', // Jinja/Flask
      '{{self}}', // Mako
      '<#if 7*7==49>VULNERABLE</#if>', // Freemarker
      '{{this}}', // Handlebars
      '{{@version}}' // Handlebars
    ];
    
    // Endpoints to test
    const endpoints = [
      url,
      `${url}/search`,
      `${url}/template`,
      `${url}/view`,
      `${url}/page`,
      `${url}/render`
    ];
    
    // Test each endpoint with each payload
    for (const endpoint of endpoints) {
      for (const payload of payloads) {
        try {
          // Test as GET parameter
          const responses = [];
          
          // Various parameter names that might be rendered in templates
          const paramNames = ['q', 'search', 'id', 'name', 'template', 'page', 'view', 'lang'];
          
          for (const param of paramNames) {
            const queryParams = {};
            queryParams[param] = payload;
            
            const response = await httpClient.get(endpoint, queryParams);
            const responseData = response.data && response.data.toString ? response.data.toString() : '';
            
            responses.push({
              param,
              responseData: responseData.substring(0, 200),
              status: response.status
            });
            
            // Check for template evaluation
            // Look for the result of expression evaluation
            if (payload.includes('7*7') && responseData.includes('49')) {
              isVulnerable = true;
              logger.warn(`Server-Side Template Injection detected at ${endpoint} with param ${param}`);
              evidence.vulnerableEndpoint = endpoint;
              evidence.vulnerableParam = param;
              evidence.payload = payload;
              evidence.signature = '7*7 evaluated to 49';
              break;
            }
            
            // Look for template engine specific responses
            if ((payload.includes('{{config}}') && responseData.includes('"Flask"')) ||
                (payload.includes('{{self}}') && responseData.includes('<TemplateReference')) ||
                (payload.includes('{{this}}') && responseData.includes('HandlebarEnvironment'))) {
              isVulnerable = true;
              logger.warn(`Server-Side Template Injection detected at ${endpoint} with specific template marker`);
              evidence.vulnerableEndpoint = endpoint;
              evidence.vulnerableParam = param;
              evidence.payload = payload;
              evidence.signature = 'Template engine data exposed';
              break;
            }
          }
          
          // Add all responses to evidence
          evidence.responses.push({
            endpoint,
            payload,
            method: 'GET',
            paramResponses: responses
          });
          
          if (isVulnerable) break;
          
          // Also test as POST parameter
          const postResponses = [];
          
          for (const param of paramNames) {
            const postData = {};
            postData[param] = payload;
            
            const response = await httpClient.post(endpoint, postData);
            const responseData = response.data && response.data.toString ? response.data.toString() : '';
            
            postResponses.push({
              param,
              responseData: responseData.substring(0, 200),
              status: response.status
            });
            
            // Check for template evaluation
            if (payload.includes('7*7') && responseData.includes('49')) {
              isVulnerable = true;
              logger.warn(`Server-Side Template Injection detected in POST at ${endpoint} with param ${param}`);
              evidence.vulnerableEndpoint = endpoint;
              evidence.vulnerableParam = param;
              evidence.payload = payload;
              evidence.method = 'POST';
              evidence.signature = '7*7 evaluated to 49';
              break;
            }
          }
          
          // Add POST responses to evidence
          evidence.responses.push({
            endpoint,
            payload,
            method: 'POST',
            paramResponses: postResponses
          });
          
          if (isVulnerable) break;
        } catch (error) {
          logger.debug(`Error testing SSTI at ${endpoint} with payload ${payload}: ${error.message}`);
        }
      }
      
      if (isVulnerable) break;
    }
    
    const details = isVulnerable 
      ? 'Server-Side Template Injection vulnerability detected. The application may evaluate user input as template code.'
      : 'No Server-Side Template Injection vulnerabilities found';
      
    const recommendation = 'Never allow user input to control template selection or be directly inserted into templates. ' +
      'Use a sandboxed template environment with limited permissions. ' +
      'Apply input validation and use safer alternatives like pre-rendering templates. ' +
      'Consider using context-specific output encoding for user data in templates.';
    
    return formatResult('server_side_template_injection', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Server-Side Template Injection: ${error.message}`);
    return formatResult(
      'server_side_template_injection',
      false,
      `Error occurred during Server-Side Template Injection testing: ${error.message}`,
      'Avoid passing user input to template rendering engines.'
    );
  }
}

/**
 * Run all advanced scanners against a target
 * @param {String} url - Target URL  
 * @returns {Promise<Object>} - Consolidated scan results
 */
async function runAllAdvancedScans(url) {
  logger.info(`Running all advanced scans against: ${url}`);
  
  const results = {
    target: url,
    timestamp: new Date().toISOString(),
    scanResults: {}
  };
  
  try {
    // Run all scanners in parallel for efficiency
    const scanFunctions = [
      scanForHostHeaderInjection,
      scanForJwtVulnerabilities,
      scanForPrototypePollution,
      scanForNoSQLInjection,
      scanForServerSideTemplateInjection
    ];
    
    const scanPromises = scanFunctions.map(scanFn => scanFn(url));
    const scanResults = await Promise.all(scanPromises);
    
    // Process and organize results
    scanResults.forEach((result, index) => {
      const scanName = scanFunctions[index].name.replace('scanFor', '');
      results.scanResults[scanName] = result;
    });
    
    logger.info(`Completed all advanced scans for: ${url}`);
    return results;
  } catch (error) {
    logger.error(`Error running advanced scans: ${error.message}`);
    return {
      target: url,
      timestamp: new Date().toISOString(),
      error: error.message,
      scanResults: {}
    };
  }
}

module.exports = {
  scanForHostHeaderInjection,
  scanForJwtVulnerabilities,
  scanForPrototypePollution,
  scanForNoSQLInjection,
  scanForServerSideTemplateInjection,
  runAllAdvancedScans
};