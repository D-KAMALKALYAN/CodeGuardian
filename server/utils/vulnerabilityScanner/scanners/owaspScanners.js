/**
 * OWASP Top 10 Vulnerability Scanners
 */
const httpClient = require('../helpers/httpClient');
const { formatResult } = require('../helpers/resultAnalyzer');
const payloadGenerator = require('../helpers/payloadGenerator');
const logger = require('../helpers/logger');
const config = require('../config');

/**
 * Scan for SQL Injection vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForSQLInjection(url) {
  logger.info(`Scanning for SQL Injection: ${url}`);
  
  try {
    const payloads = payloadGenerator.generateSqlInjectionPayloads()
      .slice(0, config.MAX_PAYLOADS_PER_VULN);
    
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // Test each payload
    for (const payload of payloads) {
      try {
        // Try both GET and POST methods
        const getResponse = await httpClient.get(`${url}`, { q: payload });
        const postResponse = await httpClient.post(`${url}`, { q: payload });
        
        // Common SQL error patterns
        const sqlErrorPatterns = [
          'sql syntax',
          'syntax error',
          'unclosed quotation',
          'sqlite_error',
          'microsoft sql',
          'mysql_fetch',
          'mysql_num_rows',
          'postgresql error',
          'odbc sql',
          'oracle database error',
          'ORA-',
          'syntax error at line'
        ];
        
        // Check response for SQL errors
        const getResponseData = getResponse.data && getResponse.data.toString ? getResponse.data.toString() : '';
        const postResponseData = postResponse.data && postResponse.data.toString ? postResponse.data.toString() : '';
        
        // Add responses to evidence
        evidence.responses.push({
          payload,
          method: 'GET',
          status: getResponse.status,
          responseExcerpt: getResponseData.substring(0, 200)
        });
        
        evidence.responses.push({
          payload,
          method: 'POST',
          status: postResponse.status,
          responseExcerpt: postResponseData.substring(0, 200)
        });
        
        // Check for SQL error patterns in responses
        if (sqlErrorPatterns.some(pattern => 
          getResponseData.toLowerCase().includes(pattern) || 
          postResponseData.toLowerCase().includes(pattern))) {
          isVulnerable = true;
          logger.warn(`SQL Injection vulnerability detected at ${url} with payload: ${payload}`);
          break;
        }
        
        // Check for blind SQL injection by comparing responses
        if (payload.includes("1=1") && payload.includes("1=2")) {
          const truePayload = payload.replace("1=2", "1=1");
          const falsePayload = payload.replace("1=1", "1=2");
          const trueResponse = await httpClient.get(`${url}`, { q: truePayload });
          const falseResponse = await httpClient.get(`${url}`, { q: falsePayload });
          
          if (trueResponse.data && falseResponse.data &&
              trueResponse.data.toString() !== falseResponse.data.toString()) {
            isVulnerable = true;
            logger.warn(`Potential blind SQL Injection vulnerability detected at ${url}`);
            break;
          }
        }
      } catch (error) {
        logger.debug(`Error testing SQL injection payload ${payload}: ${error.message}`);
      }
    }
    
    const details = isVulnerable 
      ? 'SQL Injection vulnerability detected. The application appears to pass unsanitized input directly to a database query.'
      : 'No SQL injection vulnerabilities found';
      
    const recommendation = 'Use parameterized queries or prepared statements to ensure input is properly sanitized. ' +
      'Do not concatenate user input directly into SQL queries. Consider using an ORM library and input validation.';
    
    return formatResult('sql_injection', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for SQL Injection: ${error.message}`);
    return formatResult(
      'sql_injection',
      false,
      `Error occurred during SQL Injection testing: ${error.message}`,
      'Ensure proper error handling and query parameterization in your application.'
    );
  }
}

/**
 * Scan for Cross-Site Scripting (XSS) vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForXSS(url) {
  logger.info(`Scanning for XSS: ${url}`);
  
  try {
    const payloads = payloadGenerator.generateXssPayloads()
      .slice(0, config.MAX_PAYLOADS_PER_VULN);
    
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // Test each payload
    for (const payload of payloads) {
      try {
        // Test via GET parameter
        const encodedPayload = encodeURIComponent(payload);
        const response = await httpClient.get(`${url}?q=${encodedPayload}`);
        const responseData = response.data && response.data.toString ? response.data.toString() : '';
        
        // Add response to evidence
        evidence.responses.push({
          payload,
          method: 'GET',
          status: response.status,
          responseExcerpt: responseData.substring(0, 200)
        });
        
        // Check if payload is reflected in response
        if (responseData.includes(payload)) {
          isVulnerable = true;
          logger.warn(`XSS vulnerability detected at ${url} with payload: ${payload}`);
          break;
        }
        
        // Check for partial encodings that might still be vulnerable
        const sensitiveXssPatterns = payload.match(/<\w+\s+[^>]*on\w+\s*=|<script|<img[^>]+onerror/g);
        if (sensitiveXssPatterns && sensitiveXssPatterns.some(pattern => responseData.includes(pattern))) {
          isVulnerable = true;
          logger.warn(`Potential XSS vulnerability with partial encoding detected at ${url}`);
          break;
        }
        
        // Also test via POST form submission
        const postResponse = await httpClient.post(url, { q: payload });
        const postResponseData = postResponse.data && postResponse.data.toString ? postResponse.data.toString() : '';
        
        evidence.responses.push({
          payload,
          method: 'POST',
          status: postResponse.status,
          responseExcerpt: postResponseData.substring(0, 200)
        });
        
        if (postResponseData.includes(payload)) {
          isVulnerable = true;
          logger.warn(`XSS vulnerability in POST request detected at ${url} with payload: ${payload}`);
          break;
        }
      } catch (error) {
        logger.debug(`Error testing XSS payload ${payload}: ${error.message}`);
      }
    }
    
    const details = isVulnerable 
      ? 'Cross-Site Scripting (XSS) vulnerability detected. The application reflects unfiltered input back to the browser.'
      : 'No XSS vulnerabilities found';
      
    const recommendation = 'Implement proper output encoding before reflecting user input. Use a Content Security Policy (CSP) ' +
      'and sanitize user input. Consider using frameworks that automatically escape output.';
    
    return formatResult('xss', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for XSS: ${error.message}`);
    return formatResult(
      'xss',
      false,
      `Error occurred during XSS testing: ${error.message}`,
      'Ensure proper output encoding and CSP in your application.'
    );
  }
}

/**
 * Scan for Broken Authentication vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForBrokenAuth(url) {
  logger.info(`Scanning for Broken Authentication: ${url}`);
  
  try {
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // Check for secure session management
    const loginUrl = `${url.replace(/\/$/, '')}/login`;
    try {
      const response = await httpClient.get(loginUrl);
      
      // Check cookies
      if (response.headers['set-cookie']) {
        const cookies = Array.isArray(response.headers['set-cookie']) 
          ? response.headers['set-cookie'] 
          : [response.headers['set-cookie']];
        
        evidence.cookies = cookies;
        
        // Check for missing security flags in cookies
        for (const cookie of cookies) {
          if (cookie.toLowerCase().includes('sessionid') || 
              cookie.toLowerCase().includes('session') || 
              cookie.toLowerCase().includes('token') || 
              cookie.toLowerCase().includes('auth')) {
                
            if (!cookie.toLowerCase().includes('secure') || 
                !cookie.toLowerCase().includes('httponly')) {
              isVulnerable = true;
              logger.warn(`Insecure cookie detected: ${cookie}`);
              evidence.vulnerableCookies = [cookie];
              break;
            }
          }
        }
      }
      
      // Check for HTTPS
      if (!url.toLowerCase().startsWith('https://')) {
        isVulnerable = true;
        logger.warn(`Authentication over non-HTTPS connection detected: ${url}`);
        evidence.nonHttps = true;
      }
      
      // Check for CSRF protection in login form
      const responseData = response.data && response.data.toString ? response.data.toString() : '';
      if (responseData.includes('<form') && 
          !(responseData.includes('csrf') || responseData.includes('_token'))) {
        isVulnerable = true;
        logger.warn(`Missing CSRF protection in login form: ${loginUrl}`);
        evidence.missingCsrfToken = true;
      }
      
    } catch (error) {
      logger.debug(`Error accessing login page: ${error.message}`);
    }
    
    // Try common username/password combinations
    const commonCredentials = [
      { username: 'admin', password: 'admin' },
      { username: 'admin', password: 'password' },
      { username: 'test', password: 'test' },
      { username: 'user', password: 'password123' }
    ];
    
    try {
      const loginResponses = await Promise.all(commonCredentials.map(cred => 
        httpClient.post(loginUrl, { 
          username: cred.username, 
          password: cred.password 
        }).catch(e => ({ error: e.message }))
      ));
      
      evidence.loginAttempts = loginResponses.map((resp, i) => ({
        credentials: commonCredentials[i],
        status: resp.status || 'error',
        response: resp.error || (resp.data && resp.data.substring ? resp.data.substring(0, 100) : 'Unknown')
      }));
      
      // Check if any login attempt succeeded with weak credentials
      const potentialSuccess = loginResponses.some(resp => 
        resp.status === 200 && 
        resp.headers && 
        (resp.headers['set-cookie'] || (resp.data && resp.data.includes('welcome')))
      );
      
      if (potentialSuccess) {
        isVulnerable = true;
        logger.warn(`Potential weak authentication detected: Login successful with common credentials`);
      }
    } catch (error) {
      logger.debug(`Error testing login credentials: ${error.message}`);
    }
    
    const details = isVulnerable 
      ? 'Broken Authentication vulnerability detected. The application may have weak authentication mechanisms.'
      : 'No obvious broken authentication issues found';
      
    const recommendation = 'Implement multi-factor authentication, secure session management, ' +
      'ensure HTTPS for all authentication, use strong password policies, rate limiting, and CSRF tokens. ' +
      'Consider using a trusted authentication framework or identity provider.';
    
    return formatResult('broken_authentication', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Broken Authentication: ${error.message}`);
    return formatResult(
      'broken_authentication',
      false,
      `Error occurred during authentication testing: ${error.message}`,
      'Ensure proper authentication mechanisms are in place.'
    );
  }
}

/**
 * Scan for Sensitive Data Exposure vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForSensitiveDataExposure(url) {
  logger.info(`Scanning for Sensitive Data Exposure: ${url}`);
  
  try {
    const evidence = { headers: {}, findings: [] };
    let isVulnerable = false;
    
    // Check for sensitive information in HTTP headers
    const response = await httpClient.get(url);
    
    // Store headers in evidence
    evidence.headers = response.headers;
    
    // Check for server information disclosure
    const sensitiveHeaders = ['server', 'x-powered-by', 'x-aspnet-version', 'x-asp-version'];
    for (const header of sensitiveHeaders) {
      if (response.headers[header]) {
        isVulnerable = true;
        logger.warn(`Sensitive server info exposed in headers: ${header}: ${response.headers[header]}`);
        evidence.findings.push({
          type: 'header_disclosure',
          header,
          value: response.headers[header]
        });
      }
    }
    
    // Check for HTTP usage instead of HTTPS
    if (!url.toLowerCase().startsWith('https://')) {
      isVulnerable = true;
      logger.warn(`Non-encrypted HTTP connection used: ${url}`);
      evidence.findings.push({
        type: 'non_https',
        url
      });
    }
    
    // Look for common sensitive data patterns in response
    const responseData = response.data && response.data.toString ? response.data.toString() : '';
    
    // Check for potential PII in the response
    const piiPatterns = [
      { pattern: /\b([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,})\b/g, type: 'email' },
      { pattern: /\b(?:\d[ -]*?){13,16}\b/g, type: 'potential_credit_card' },
      { pattern: /\b\d{3}[-. ]?\d{2}[-. ]?\d{4}\b/g, type: 'potential_ssn' }
    ];
    
    for (const { pattern, type } of piiPatterns) {
      const matches = responseData.match(pattern);
      if (matches && matches.length > 0) {
        isVulnerable = true;
        logger.warn(`Potential ${type} found in response`);
        evidence.findings.push({
          type: 'pii_exposure',
          piiType: type,
          count: matches.length
        });
      }
    }
    
    // Check for missing security headers
    const securityHeaders = [
      'strict-transport-security',
      'content-security-policy',
      'x-content-type-options',
      'x-frame-options'
    ];
    
    const missingHeaders = securityHeaders.filter(header => !response.headers[header]);
    if (missingHeaders.length > 0) {
      isVulnerable = true;
      logger.warn(`Missing security headers: ${missingHeaders.join(', ')}`);
      evidence.findings.push({
        type: 'missing_security_headers',
        missingHeaders
      });
    }
    
    const details = isVulnerable 
      ? 'Sensitive Data Exposure vulnerability detected. The application may expose sensitive information.'
      : 'No obvious sensitive data exposure issues found';
      
    const recommendation = 'Implement proper data encryption for sensitive information, use HTTPS, ' +
      'add security headers, minimize server information disclosure, ' +
      'and ensure sensitive data is not included in responses.';
    
    return formatResult('sensitive_data_exposure', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Sensitive Data Exposure: ${error.message}`);
    return formatResult(
      'sensitive_data_exposure',
      false,
      `Error occurred during sensitive data exposure testing: ${error.message}`,
      'Ensure secure headers and encrypt sensitive data.'
    );
  }
}

/**
 * Scan for XML External Entity (XXE) vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForXXE(url) {
  logger.info(`Scanning for XXE: ${url}`);
  
  try {
    const payloads = payloadGenerator.generateXxePayloads()
      .slice(0, config.MAX_PAYLOADS_PER_VULN);
    
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // Test each payload against potential XML endpoints
    const xmlEndpoints = [
      `${url}`,
      `${url}/api/xml`,
      `${url}/upload`,
      `${url}/import`
    ];
    
    for (const endpoint of xmlEndpoints) {
      for (const payload of payloads) {
        try {
          const response = await httpClient.post(endpoint, payload, {
            headers: { 'Content-Type': 'application/xml' }
          });
          
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          
          // Add response to evidence
          evidence.responses.push({
            endpoint,
            payload: payload.substring(0, 100) + '...',
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // Check for common system file contents that might be leaked through XXE
          const xxeIndicators = [
            'root:x:0:0',           // Linux /etc/passwd
            'Administrator:',       // Windows user
            '<!DOCTYPE html>',      // HTML file read
            'file not found',       // Common error when file reading
            'java.io.FileNotFoundException', // Java exception
            'ftp.example.com'       // External entity connection attempt
          ];
          
          if (xxeIndicators.some(indicator => responseData.includes(indicator))) {
            isVulnerable = true;
            logger.warn(`Potential XXE vulnerability detected at ${endpoint}`);
            evidence.vulnerableEndpoint = endpoint;
            break;
          }
        } catch (error) {
          logger.debug(`Error testing XXE payload at ${endpoint}: ${error.message}`);
        }
      }
      
      if (isVulnerable) break;
    }
    
    // Also test for blind XXE using external entity references
    if (!isVulnerable) {
      try {
        // Custom domain for external entity test (should be replaced with a controlled domain in real testing)
        const externalEntityPayload = `<?xml version="1.0" encoding="ISO-8859-1"?>
          <!DOCTYPE foo [
            <!ELEMENT foo ANY>
            <!ENTITY % xxe SYSTEM "http://xxe-test-domain.example.com/xxe-test">
            %xxe;
          ]>
          <foo>test</foo>`;
        
        await httpClient.post(url, externalEntityPayload, {
          headers: { 'Content-Type': 'application/xml' },
          timeout: 5000 // Short timeout for blind XXE test
        });
        
        // In a real scenario, we would check if the external domain received a request
        // Here we're just logging this as a technique that would be used
        logger.debug('Blind XXE test completed (would check external domain logs in real test)');
      } catch (error) {
        // Timeout might indicate blind XXE
        if (error.code === 'ECONNABORTED') {
          logger.debug('Potential blind XXE detected (connection timeout)');
        }
      }
    }
    
    const details = isVulnerable 
      ? 'XML External Entity (XXE) vulnerability detected. The application processes external XML entities.'
      : 'No XXE vulnerabilities found';
      
    const recommendation = 'Disable XML external entity and DTD processing in XML parsers. ' +
      'Use less complex data formats like JSON when possible. ' +
      'Patch or upgrade XML processors and libraries, and validate XML input.';
    
    return formatResult('xxe', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for XXE: ${error.message}`);
    return formatResult(
      'xxe',
      false,
      `Error occurred during XXE testing: ${error.message}`,
      'Ensure secure XML parser configurations.'
    );
  }
}

/**
 * Scan for Insecure Deserialization vulnerabilities
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForInsecureDeserialization(url) {
  logger.info(`Scanning for Insecure Deserialization: ${url}`);
  
  try {
    const deserializationPayloads = payloadGenerator.generateDeserializationPayloads();
    const evidence = { responses: [] };
    let isVulnerable = false;
    
    // Test PHP-style serialized data
    for (const phpPayload of deserializationPayloads.php) {
      try {
        const response = await httpClient.post(url, phpPayload, {
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
        });
        
        const responseData = response.data && response.data.toString ? response.data.toString() : '';
        evidence.responses.push({
          payload: phpPayload,
          type: 'PHP',
          status: response.status,
          responseExcerpt: responseData.substring(0, 200)
        });
        
        // Check for PHP deserialization errors
        if (responseData.includes('unserialize') || 
            responseData.includes('PHP Error') ||
            responseData.includes('Uncaught Exception')) {
          isVulnerable = true;
          logger.warn(`Potential PHP deserialization vulnerability detected at ${url}`);
          break;
        }
      } catch (error) {
        logger.debug(`Error testing PHP deserialization payload: ${error.message}`);
      }
    }
    
    // Test Java-style serialized data
    if (!isVulnerable) {
      for (const javaPayload of deserializationPayloads.java) {
        try {
          const response = await httpClient.post(url, Buffer.from(javaPayload, 'base64'), {
            headers: { 'Content-Type': 'application/octet-stream' }
          });
          
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          evidence.responses.push({
            payload: javaPayload.substring(0, 20) + '...',
            type: 'Java',
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // Check for Java deserialization errors
          if (responseData.includes('ClassNotFoundException') || 
              responseData.includes('java.io') ||
              responseData.includes('ObjectInputStream')) {
            isVulnerable = true;
            logger.warn(`Potential Java deserialization vulnerability detected at ${url}`);
            break;
          }
        } catch (error) {
          logger.debug(`Error testing Java deserialization payload: ${error.message}`);
        }
      }
    }
    
    // Test Node.js deserialization (prototype pollution)
    if (!isVulnerable) {
      for (const nodePayload of deserializationPayloads.node) {
        try {
          const response = await httpClient.post(url, nodePayload, {
            headers: { 'Content-Type': 'application/json' }
          });
          
          const responseData = response.data && response.data.toString ? response.data.toString() : '';
          evidence.responses.push({
            payload: nodePayload,
            type: 'Node.js',
            status: response.status,
            responseExcerpt: responseData.substring(0, 200)
          });
          
          // For prototype pollution we'd need to observe application behavior changes
          // Here we're just checking for error indicators
          if (responseData.includes('Unexpected token') || 
              responseData.includes('SyntaxError') ||
              responseData.includes('malformed')) {
            evidence.potentialNodeIssue = true;
            logger.debug(`Potential Node.js deserialization response detected at ${url}`);
          }
        } catch (error) {
          logger.debug(`Error testing Node.js deserialization payload: ${error.message}`);
        }
      }
    }
    
    const details = isVulnerable 
      ? 'Insecure Deserialization vulnerability detected. The application deserializes untrusted data.'
      : 'No obvious insecure deserialization vulnerabilities found';
      
    const recommendation = 'Avoid deserializing data from untrusted sources. Implement integrity checks, ' +
      'enforce strict type constraints, use safer data formats like JSON, and monitor deserialization exceptions. ' +
      'Consider using serialization mediation frameworks that don\'t allow arbitrary class instantiation.';
    
    return formatResult('insecure_deserialization', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Insecure Deserialization: ${error.message}`);
    return formatResult(
      'insecure_deserialization',
      false,
      `Error occurred during insecure deserialization testing: ${error.message}`,
      'Ensure secure deserialization practices.'
    );
  }
}

/**
 * Scan for Security Misconfiguration
 * @param {String} url - Target URL
 * @returns {Promise<Object>} - Scan result
 */
async function scanForSecurityMisconfig(url) {
  logger.info(`Scanning for Security Misconfiguration: ${url}`);
  
  try {
    const evidence = { 
      headers: {},
      findings: [],
      directories: []
    };
    let isVulnerable = false;
    
    // Check for missing security headers
    const response = await httpClient.get(url);
    evidence.headers = response.headers;
    
    const securityHeaders = config.SECURITY_HEADERS;
    const missingHeaders = securityHeaders.filter(header => !response.headers[header.toLowerCase()]);
    
    if (missingHeaders.length > 0) {
      isVulnerable = true;
      logger.warn(`Missing security headers: ${missingHeaders.join(', ')}`);
      evidence.findings.push({
        type: 'missing_security_headers',
        missingHeaders
      });
    }
    
    // Check for directory listing
    const commonDirectories = ['/assets', '/images', '/js', '/css', '/uploads', '/backup', '/admin', '/config'];
    
    for (const dir of commonDirectories) {
      try {
        const dirUrl = new URL(dir, url).toString();
        const dirResponse = await httpClient.get(dirUrl);
        const responseData = dirResponse.data && dirResponse.data.toString ? dirResponse.data.toString() : '';
        
        evidence.directories.push({
          url: dirUrl,
          status: dirResponse.status,
          responseExcerpt: responseData.substring(0, 100)
        });
        
        // Look for directory listing markers
        if (dirResponse.status === 200 && 
            (responseData.includes('Index of /') || 
             responseData.includes('Directory Listing For') ||
             (responseData.includes('<a href="') && responseData.includes('Parent Directory')))) {
          isVulnerable = true;
          logger.warn(`Directory listing enabled at ${dirUrl}`);
          evidence.findings.push({
            type: 'directory_listing',
            url: dirUrl
          });
        }
      } catch (error) {
        logger.debug(`Error checking directory ${dir}: ${error.message}`);
      }
    }
    
    // Check for debug/dev/test endpoints
    const debugEndpoints = ['/debug', '/test', '/phpinfo.php', '/info.php', '/dev', '/console', '/api/debug'];
    
    for (const endpoint of debugEndpoints) {
      try {
        const debugUrl = new URL(endpoint, url).toString();
        const debugResponse = await httpClient.get(debugUrl);
        
        if (debugResponse.status === 200) {
          const responseData = debugResponse.data && debugResponse.data.toString ? debugResponse.data.toString() : '';
          
          evidence.directories.push({
            url: debugUrl,
            status: debugResponse.status,
            responseExcerpt: responseData.substring(0, 100)
          });
          
          if (responseData.includes('phpinfo()') || 
              responseData.includes('DEBUG MODE') ||
              responseData.includes('development mode') ||
              responseData.includes('stack trace') ||
              responseData.includes('exception at')) {
            isVulnerable = true;
            logger.warn(`Debug/development endpoint exposed at ${debugUrl}`);
            evidence.findings.push({
              type: 'debug_endpoint',
              url: debugUrl
            });
          }
        }
      } catch (error) {
        logger.debug(`Error checking debug endpoint ${endpoint}: ${error.message}`);
      }
    }
    
    // Check for default credentials
    const defaultCredPages = ['/admin', '/login', '/wp-admin', '/administrator', '/panel'];
    
    for (const page of defaultCredPages) {
      try {
        const loginUrl = new URL(page, url).toString();
        const loginResponse = await httpClient.get(loginUrl);
        
        if (loginResponse.status === 200) {
          // We don't actually test logins here, just note their existence for the report
          evidence.loginPages = evidence.loginPages || [];
          evidence.loginPages.push(loginUrl);
          
          // In a real scan, we might attempt common credentials
          logger.debug(`Login page found at ${loginUrl} - would test default credentials in a real scan`);
        }
      } catch (error) {
        logger.debug(`Error checking login page ${page}: ${error.message}`);
      }
    }
    
    const details = isVulnerable 
      ? 'Security Misconfiguration detected. The application has missing security headers or exposed directories/endpoints.'
      : 'No obvious security misconfigurations found';
      
    const recommendation = 'Implement proper security headers, disable directory listings, ' +
      'remove debug/development endpoints in production, use secure default configurations, ' +
      'and implement a patching strategy to keep all components updated.';
    
    return formatResult('security_misconfiguration', isVulnerable, details, recommendation, evidence);
  } catch (error) {
    logger.error(`Error scanning for Security Misconfiguration: ${error.message}`);
    return formatResult(
      'security_misconfiguration',
      false,
      `Error occurred during security misconfiguration testing: ${error.message}`,
      'Ensure application configuration follows best practices.'
    );
  }
}

// Export all scanner functions
module.exports = {
  scanForSQLInjection,
  scanForXSS,
  scanForBrokenAuth,
  scanForSensitiveDataExposure,
  scanForXXE,
  scanForInsecureDeserialization,
  scanForSecurityMisconfig,
  scanForAccessControlIssues: async (url) => {
    // Implementation for access control issues
    return formatResult(
      'access_control_issues',
      false,
      'Access control scan not implemented in this version',
      'Implement proper access controls and authorization checks.'
    );
  },
  scanForCSRF: async (url) => {
    // Implementation for CSRF
    return formatResult(
      'csrf',
      false,
      'CSRF scan not implemented in this version',
      'Use CSRF tokens for all state-changing operations.'
    );
  },
  scanForVulnerableComponents: async (url) => {
    // Implementation for vulnerable components
    return formatResult(
      'vulnerable_components',
      false,
      'Vulnerable components scan not implemented in this version',
      'Keep all dependencies up-to-date and regularly audit them.'
    );
  }
};